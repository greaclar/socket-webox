# 安装

socket-webox是一个前端WebSocket封装库，结合事件中心，来对后端推送消息进行分类派发。可实现灵活配置容错率高的心跳检测机制，区分网络抖动、客户端掉线。

```shell
# 本地安装
npm i socket-webox -S
```

# 前端原生WebSocket的一些问题

> websocket和http一样是应用层协议，在传输层同样使用了TCP。但地址以ws:或wss:开头。它与http的区别在于，websocket可以互相发起请求。当有新消息时，服务的主动通知客户端，无需客户端主动向服务器询问。

+ 无法判断网络状态。在网络不佳，或者浏览器断网的情况下，WebSocket实例的readyState依旧为open状态，向后端发送消息不会报错，也依旧会认为自己能接收后端的消息。

+ 在使用组件化开发的框架时，往往不同的业务组件需要接收各自的WebSocket消息，每个WebSocket实例只有一个message事件回调，组件间共用时，它们都可以监听到其它组件的更新信息。

+ 当后端侧关闭websocket通道后（或服务中断下线），前端WebSocket实例的readyState变为close状态，但实例依旧存在。如果实例上绑定open、close、message等事件的监听，并不会解除。即使后端恢复了，该WebSocket实例也无法再使用。

+ 需要考虑的边界情况分散：初始化前，需要手动判断当前浏览器是否兼容；实例化时，需要通过监听实例error事件来检测建立连接错误、后端服务中断错误；WebSocket实例无法检测设备端网络不佳、网络断线的情况。

# socket-webox特点

使用上：将WebSocket与事件中心整合，让其更好用，只需初始化实例，然后监听事件即可。

功能上：涵盖WebSocket的全生命周期。通过它无需提前判断浏览器是否兼容、异常后找到实例把注册的事件一个个解除。这些能力只需调用一个api即可。

> socket-webox不与任何框架耦合，原生环境可用，但在组件化的框架中使用会有更好的体验。注意，开发时使用了主流的ES6+语法，未来也不准备polyfill，在旧浏览器中可能无法正常运行。

## 使用特点

socket-webox使用上，主要就是监听事件，然后在事件回调里进行业务操作或者对实例进行配置。可监听的事件分两类：

1. 后端响应消息事件，但会进行一对一的事件派发，具体业务注册对应的监听事件。该事件可随组件销毁而取消。

2. WebSocket生命周期事件，会代理触发websocket的原生事件: open（打开）、error（服务错误）、close（关闭），并增加了心跳响应超时事件，结合灵活的api可辨别客户端网络抖动、掉线的情况。同时把浏览器不兼容websocket也划到了error事件中。

   > 以上事件涵盖整个WebSocket的全生命周期，将开始提到的分散的边界情况进行了统一管理。
   >
   > PS：所有事件只能监听注册和取消，不能通过外部手动来派事件。事件派发只能是内部来处理。

## 功能特点

渐进式使用体验设计：

+ 使用上和原生的WebSocket类似，初始化，然后监听事件即可。只是要和后端沟通好响应数据的格式。
+ 如果需要心跳检测，传递第二个参数，然后监听心跳超时事件即可。

更精细的后端响应事件派发：

+ 只需一个WebSocket连接实例，即可对多个业务组件进行一对一的消息派发。
+ 对后端消息进行预处理，根据不同的消息，派发不同的事件，不同组件监听对应的事件即可。
+ 当组件销毁时，可在其销毁钩子中，手动解除某个的事件监听。

灵活的心跳检测机制：
+ 在自定义间隔内发送心跳包给后端，如果后端响应超时，会派发超时事件，并自动停止心跳检测。
+ 可设置连续超时一定次数后，才派发响应超时事件和停止心跳检测，防止因为网络抖动误报。
+ 可在超时事件派发时，提醒用户网络差，然后设置更久的响应等待时间，并重新发起心跳检测。通过判断超时事件触发阈值，以提示用户，可能已经断线。
+ 每次调用心跳检测api时，会先自动停止正在运行的心跳检测，代码更健壮。

实例销毁更简单：
+ 提供销毁的接口，会把所有的实例监听的原生事件、心跳检测定时器、事件中心注册的事件全部销毁。
+ 发起连接的api可调用多次，以实现断线重连，并且每次重连都会先清除旧WebSocket实例上的原生事件监听，内存管理更简单。

typescript类型提示：
+ 可设置前后端发送消息时，数据的类型结构。
+ 提供open、error、close、心跳响应超时事件名的类型对象，导入后即可使用，无需担心拼写错误。

错误管理：

+ 初始化WebSocket的地址无法连接，事件中心会派发error事件，并将错误对象传递。然后派发close事件。这个过程和WebSocket实例原生事件的触发流程一致。

+ 如果客户端不支持WebSocket，实例化时会抛出异常，阻止代码往下执行。但实例自身提供了检测当前浏览器是否包含WebSocket实例的静态方法，可通过它来预先判断一下，再实例化。

  > 注意：心跳检测触发的网络延迟事件并不是错误事件，因为WebSocket实例本身功能正常，可处理发送和接收消息的任务，只是网络环境异常，无法让数据顺利发送和接收，当用户的网络正常后依旧可用。
  >
  > 但error触发是实例层面的问题，网络正常可能也无法使用。

  



