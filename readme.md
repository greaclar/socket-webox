# 前端原生WebSocket的一些问题



websocket和http一样是应用层协议，在传输层同样使用了TCP。但地址已ws:或wss:开头。它与http的区别在于，websocket可以互相发起请求。当有新消息时，服务的主动通知客户端，无需客户端主动询问。

无法判断网络状态。在网络不佳，或者浏览器断网的情况下，WebSocket实例的readyState依旧为open状态，向后端发送消息不会报错，也依旧会认为自己能接收后端的消息。

在使用组件化开发的框架时，往往不同的业务组件需要接收各自的WebSocket消息，每个WebSocket实例只有一个message事件回调，组件间共用时，它们都可以监听到其它组件的更新信息。

当后端侧关闭websocket通道后（或服务中断下线），前端WebSocket实例的readyState变为close状态，但实例依旧存在。如果实例上绑定open、close、message等事件的监听，并不会解除。即使后端恢复了，该WebSocket实例也无法再使用。

需要考虑的边界情况分散：初始化前，需要手动判断当前浏览器是否兼容；实例化时，需要通过监听实例error事件来检测建立连接错误、后端服务中断错误；WebSocket实例无法检测设备端网络不佳、网络断线的情况。

# 安装

```shell
# 本地安装
npm i socket-webox -S
```

# socket-webox特点

使用上：将WebSocket与事件中心整合，让其更好用，只需初始化实例，然后监听事件即可。

功能上：涵盖WebSocket的全生命周期。通过它无需提前判断浏览器是否兼容、异常后找到实例把注册的事件一个个解除。这些能力只需调用一个api即可。

> socket-webox不与任何框架耦合，原生环境可用，但在组件化的框架中使用会有更好的体验。注意，开发时使用了主流的ES6+语法，未来也不准备polyfill，在旧浏览器中可能无法正常运行。

## 使用特点

socket-webox使用上，主要就是监听事件，然后在事件回调里进行业务操作或者对实例进行配置。可监听的事件分两类：

1. 后端响应消息事件，但会进行一对一的事件派发，具体业务注册对应的监听事件。该事件可随组件销毁而取消。

2. WebSocket生命周期事件，会代理触发websocket的原生事件: open（打开）、error（服务错误）、close（关闭），并增加了心跳响应超时事件，结合灵活的api可辨别客户端网络抖动、掉线的情况。同时把浏览器不兼容websocket也划到了error事件中。

   > 以上事件涵盖整个WebSocket的全生命周期，将开始提到的分散的边界情况进行了统一管理。
   >
   > PS：所有事件只能监听注册和取消，不能通过外部手动来派事件。事件派发只能是内部来处理。

## 功能特点

渐进式使用体验设计：

+ 使用上和原生的WebSocket类似，初始化，然后监听事件即可。只是要和后端沟通好响应数据的格式。
+ 如果需要心跳检测，传递第二个参数，并监听心跳超时事件即可。

灵活的心跳检测机制：
+ 在自定义间隔内发送心跳包给后端，如果后端响应超时，会派发超时事件，并自动停止检测。
+ 可设置连续超时一定次数后，才派发响应超时事件，防止因为网络抖动误报。
+ 可在超时事件派发时，设置更久的响应等待时间，并重新发起心跳检测，有效检测网络差的情况。通过判断超时事件触发阈值，以提示用户，可能已经断线。
+ 多次调用心跳检测启动的api时，会先自动停止正在运行的心跳检测，代码更健壮。

更精细的message事件派发：
+ 只需一个WebSocket连接实例，即可对多个业务组件进行一对一的消息派发。
+ 对后端消息进行预处理，根据不同的消息，派发不同的事件，不同组件监听对应的事件即可。
+ 当组件销毁时，可在其销毁钩子中，手动解除某个的事件监听。

实例销毁更简单：
+ 提供销毁的接口，会把所有的实例监听的原生事件、心跳检测定时器、事件中心注册的事件全部销毁。

typescript类型提示：
+ 可设置前后端发送消息时，数据的类型结构。
+ 提供open、error、close、心跳响应超时事件名的类型对象，导入后即可使用，无需担心拼写错误。

其它；

+ 当浏览器不支持websocket、初始化websocket的地址无法连接、websocket后端中断，这些错误都会通过error事件来统一通知。

  



